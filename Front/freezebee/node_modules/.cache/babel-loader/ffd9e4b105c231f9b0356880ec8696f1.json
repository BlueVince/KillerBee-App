{"ast":null,"code":"const encryption = require('../encryption/encryption');\n\nconst encryptionClient = encryption.client;\nmodule.exports = {\n  /**\r\n   * Create a connection with the API\r\n   * @param {String} ip API's IP address\r\n   * @param {String} url path to fetch from\r\n   * @param {function} callback (Object: err, Object: result) the function to callback\r\n   */\n  CreateConnection: function (ip, path, callback) {\n    try {\n      encryptionClient.InitiateConnection(ip, (err, result) => {\n        // TODO, fetch \"ip + path\"\n        fetch(\"data.json\", {\n          // TODO, post verb\n          headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json'\n          }\n        }).then(res => res.json()).then(result => {\n          encryptionClient.ConnectionAccepted(ip, result.publicKey, (err, result) => {\n            if (!err) callback(false, JSON.parse(result));else callback(error, null);\n          });\n        }, error => {\n          callback(error, null);\n        });\n      });\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Create a connection with the API\r\n   * @param {String} ip API's IP address\r\n   * @param {String} url path to fetch from\r\n   * @param {Object} data The data to send in the body of the fetch request\r\n   * @param {function} callback (Object: err, Object: result) the function to callback\r\n   */\n  FetchAPI: function (ip, path, data, callback) {\n    try {\n      encryptionClient.EncryptForSending(ip, data, (err, result) => {\n        // TODO, fetch \"ip + path\"\n        fetch(\"data.json\", {\n          // TODO, post verb\n          headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json'\n          },\n          body: data\n        }).then(res => res.json()).then(result => {\n          encryptionClient.DecryptReceived(ip, result, (err, result) => {\n            if (!err) callback(false, JSON.parse(result));else callback(error, null);\n          });\n        }, error => {\n          callback(error, null);\n        });\n      });\n    } catch (error) {\n      callback(error, null);\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/vince/OneDrive/Documents/A5 - Option 1/cybersecurite/freezebee/src/encryption/fetching.js"],"names":["encryption","require","encryptionClient","client","module","exports","CreateConnection","ip","path","callback","InitiateConnection","err","result","fetch","headers","then","res","json","ConnectionAccepted","publicKey","JSON","parse","error","FetchAPI","data","EncryptForSending","body","DecryptReceived"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,0BAAD,CAA1B;;AACA,MAAMC,gBAAgB,GAAGF,UAAU,CAACG,MAApC;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACb;AACJ;AACA;AACA;AACA;AACA;AACIC,EAAAA,gBAAgB,EAAE,UAAUC,EAAV,EAAcC,IAAd,EAAoBC,QAApB,EAA8B;AAC5C,QAAI;AACAP,MAAAA,gBAAgB,CAACQ,kBAAjB,CAAoCH,EAApC,EAAwC,CAACI,GAAD,EAAMC,MAAN,KAAiB;AACrD;AACAC,QAAAA,KAAK,CAAC,WAAD,EAAc;AACf;AACAC,UAAAA,OAAO,EAAE;AACL,4BAAgB,kBADX;AAEL,sBAAU;AAFL;AAFM,SAAd,CAAL,CAOEC,IAPF,CAOOC,GAAG,IAAIA,GAAG,CAACC,IAAJ,EAPd,EAQKF,IARL,CASSH,MAAD,IAAY;AACRV,UAAAA,gBAAgB,CAACgB,kBAAjB,CAAoCX,EAApC,EAAwCK,MAAM,CAACO,SAA/C,EAA0D,CAACR,GAAD,EAAMC,MAAN,KAAiB;AACvE,gBAAI,CAACD,GAAL,EAAUF,QAAQ,CAAC,KAAD,EAAQW,IAAI,CAACC,KAAL,CAAWT,MAAX,CAAR,CAAR,CAAV,KACKH,QAAQ,CAACa,KAAD,EAAQ,IAAR,CAAR;AACR,WAHD;AAIH,SAdT,EAeSA,KAAD,IAAW;AACPb,UAAAA,QAAQ,CAACa,KAAD,EAAQ,IAAR,CAAR;AACH,SAjBT;AAmBH,OArBD;AAsBH,KAvBD,CAuBE,OAAOA,KAAP,EAAc;AACZb,MAAAA,QAAQ,CAACa,KAAD,EAAQ,IAAR,CAAR;AACH;AACJ,GAlCY;;AAoCb;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,QAAQ,EAAE,UAAUhB,EAAV,EAAcC,IAAd,EAAoBgB,IAApB,EAA0Bf,QAA1B,EAAoC;AAC1C,QAAI;AACAP,MAAAA,gBAAgB,CAACuB,iBAAjB,CAAmClB,EAAnC,EAAuCiB,IAAvC,EAA6C,CAACb,GAAD,EAAMC,MAAN,KAAiB;AAC1D;AACAC,QAAAA,KAAK,CAAC,WAAD,EAAc;AACf;AACAC,UAAAA,OAAO,EAAE;AACL,4BAAgB,kBADX;AAEL,sBAAU;AAFL,WAFM;AAMfY,UAAAA,IAAI,EAAEF;AANS,SAAd,CAAL,CAQET,IARF,CAQOC,GAAG,IAAIA,GAAG,CAACC,IAAJ,EARd,EASKF,IATL,CAUSH,MAAD,IAAY;AACRV,UAAAA,gBAAgB,CAACyB,eAAjB,CAAiCpB,EAAjC,EAAqCK,MAArC,EAA6C,CAACD,GAAD,EAAMC,MAAN,KAAiB;AAC1D,gBAAI,CAACD,GAAL,EAAUF,QAAQ,CAAC,KAAD,EAAQW,IAAI,CAACC,KAAL,CAAWT,MAAX,CAAR,CAAR,CAAV,KACKH,QAAQ,CAACa,KAAD,EAAQ,IAAR,CAAR;AACR,WAHD;AAIH,SAfT,EAgBSA,KAAD,IAAW;AACPb,UAAAA,QAAQ,CAACa,KAAD,EAAQ,IAAR,CAAR;AACH,SAlBT;AAoBH,OAtBD;AAuBH,KAxBD,CAwBE,OAAOA,KAAP,EAAc;AACZb,MAAAA,QAAQ,CAACa,KAAD,EAAQ,IAAR,CAAR;AACH;AACJ;AAvEY,CAAjB","sourcesContent":["const encryption = require('../encryption/encryption');\r\nconst encryptionClient = encryption.client;\r\n\r\nmodule.exports = {\r\n    /**\r\n     * Create a connection with the API\r\n     * @param {String} ip API's IP address\r\n     * @param {String} url path to fetch from\r\n     * @param {function} callback (Object: err, Object: result) the function to callback\r\n     */\r\n    CreateConnection: function (ip, path, callback) {\r\n        try {\r\n            encryptionClient.InitiateConnection(ip, (err, result) => {\r\n                // TODO, fetch \"ip + path\"\r\n                fetch(\"data.json\", {\r\n                    // TODO, post verb\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'Accept': 'application/json'\r\n                    },\r\n                }\r\n                ).then(res => res.json())\r\n                    .then(\r\n                        (result) => {\r\n                            encryptionClient.ConnectionAccepted(ip, result.publicKey, (err, result) => {\r\n                                if (!err) callback(false, JSON.parse(result));\r\n                                else callback(error, null);\r\n                            });\r\n                        },\r\n                        (error) => {\r\n                            callback(error, null);\r\n                        }\r\n                    )\r\n            });\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Create a connection with the API\r\n     * @param {String} ip API's IP address\r\n     * @param {String} url path to fetch from\r\n     * @param {Object} data The data to send in the body of the fetch request\r\n     * @param {function} callback (Object: err, Object: result) the function to callback\r\n     */\r\n    FetchAPI: function (ip, path, data, callback) {\r\n        try {\r\n            encryptionClient.EncryptForSending(ip, data, (err, result) => {\r\n                // TODO, fetch \"ip + path\"\r\n                fetch(\"data.json\", {\r\n                    // TODO, post verb\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'Accept': 'application/json'\r\n                    },\r\n                    body: data\r\n                }\r\n                ).then(res => res.json())\r\n                    .then(\r\n                        (result) => {\r\n                            encryptionClient.DecryptReceived(ip, result, (err, result) => {\r\n                                if (!err) callback(false, JSON.parse(result));\r\n                                else callback(error, null);\r\n                            });\r\n                        },\r\n                        (error) => {\r\n                            callback(error, null);\r\n                        }\r\n                    )\r\n            });\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}