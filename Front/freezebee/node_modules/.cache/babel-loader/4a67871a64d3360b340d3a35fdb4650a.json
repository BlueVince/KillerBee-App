{"ast":null,"code":"const NodeRSA = require('node-rsa');\n\nconst base64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\nString.prototype.replaceAt = function (index, replacement) {\n  return this.substr(0, index) + replacement + this.substr(index + replacement.length);\n}; // Connections\n\n\nvar connections = [];\n/**\r\n * Create the connection with the given options.\r\n * @param {String} interlocutor The reference to the end point (ip, url, ...)\r\n * @param {bool} authorised \r\n * @param {RSA} privateKey \r\n * @param {RSA} publicKey \r\n * @param {RSA} connPublicKey \r\n * @returns new connection, null if the interlocutor already exists\r\n */\n\nfunction MakeConnection(interlocutor, authorised = true, privateKey = null, publicKey = null, connPublicKey = null) {\n  if (GetConnection(interlocutor)) return null;else {\n    let conn = {\n      'interlocutor': interlocutor,\n      'authorised': authorised,\n      'privateKey': privateKey,\n      'publicKey': publicKey,\n      'connPublicKey': connPublicKey\n    };\n    connections.push(conn);\n    return conn;\n  }\n}\n\n_c = MakeConnection;\n\nfunction GetConnection(interlocutor) {\n  return connections.find(c => c.interlocutor == interlocutor);\n}\n\n_c2 = GetConnection;\n\nfunction DeleteConnection(interlocutor) {\n  let conn = GetConnection(interlocutor);\n  if (conn) connections.splice(connections.indexOf(conn));\n} // Content encoding\n\n\n_c3 = DeleteConnection;\n\nfunction getRandomInt(start = 0, length = 1) {\n  return Math.floor(Math.random() * length + start);\n}\n/**\r\n * Randomly generate a set of keys.\r\n * @returns Set of keys to encode a message\r\n */\n\n\nfunction GenerateEncodingKey() {\n  let subKey = '',\n      base64MapCopy = base64Map;\n  let transKey = [],\n      polyAlphaKey = [],\n      numberMap = []; // substitution key generation using base 64 map\n\n  while (base64MapCopy.length > 0) {\n    let i = getRandomInt(0, base64MapCopy.length);\n    subKey += base64MapCopy[i];\n    base64MapCopy = base64MapCopy.substr(0, i) + base64MapCopy.substring(i + 1);\n  } // number map generation\n\n\n  let transKeyLength = getRandomInt(20, 10);\n\n  for (let i = 0; i < transKeyLength; i++) {\n    numberMap.push(i);\n  } // transposition key generation using number map\n\n\n  while (numberMap.length > 0) {\n    let i = getRandomInt(0, numberMap.length);\n    transKey.push(numberMap[i]);\n    numberMap.splice(i, 1);\n  } // poly alpha key generation\n\n\n  let polyAlphaKeyLength = getRandomInt(16, 8);\n\n  for (let i = 0; i < polyAlphaKeyLength; i++) {\n    polyAlphaKey.push(getRandomInt(0, 26));\n  }\n\n  return {\n    'subKey': subKey,\n    'transKey': transKey,\n    'polyAlphaKey': polyAlphaKey\n  };\n}\n/**\r\n * Encode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} toEncode The message to encode (base 64)\r\n * @param {Object} key Set of keys\r\n * @returns Encoded message\r\n */\n\n\n_c4 = GenerateEncodingKey;\n\nfunction Encode(toEncode, key) {\n  // substitution\n  for (let i = 0; i < toEncode.length; i++) {\n    let iMap = base64Map.indexOf(toEncode[i]);\n    if (iMap >= 0) toEncode = toEncode.replaceAt(i, key.subKey[iMap]);\n  } // transposition\n\n\n  while (toEncode.length % key.transKey.length != 0) toEncode += '*';\n\n  let transposed = toEncode;\n\n  for (let i = 0; i < toEncode.length; i++) {\n    let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length);\n    transposed = transposed.replaceAt(iTrans, toEncode[i]);\n  }\n\n  toEncode = transposed; // custom polyalpha substition\n\n  for (let i = 0; i < toEncode.length; i++) {\n    let iMap = base64Map.indexOf(toEncode[i]);\n\n    if (iMap >= 0) {\n      let iPoly = i % key.polyAlphaKey.length;\n      iMap = (iMap + key.polyAlphaKey[iPoly]) % key.subKey.length;\n      toEncode = toEncode.replaceAt(i, key.subKey[iMap]);\n    }\n  } // return encoded 'toEncode' string\n\n\n  return toEncode;\n}\n/**\r\n * Decode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} encoded Encoded message to decode\r\n * @param {Object} key Set of keys\r\n * @returns Decoded message (base 64)\r\n */\n\n\n_c5 = Encode;\n\nfunction Decode(encoded, key) {\n  // custom polyalpha substition\n  for (let i = 0; i < encoded.length; i++) {\n    let iMap = key.subKey.indexOf(encoded[i]);\n\n    if (iMap >= 0) {\n      let iPoly = i % key.polyAlphaKey.length;\n      iMap = (iMap - key.polyAlphaKey[iPoly] + base64Map.length) % base64Map.length;\n      encoded = encoded.replaceAt(i, base64Map[iMap]);\n    }\n  } // transposition\n\n\n  let transposed = encoded;\n\n  for (let i = 0; i < encoded.length; i++) {\n    let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length);\n    transposed = transposed.replaceAt(i, encoded[iTrans]);\n  }\n\n  encoded = transposed;\n\n  while (encoded[encoded.length - 1] == '*') encoded = encoded.substr(0, encoded.length - 1); // substitution\n\n\n  for (let i = 0; i < encoded.length; i++) {\n    let iMap = key.subKey.indexOf(encoded[i]);\n    if (iMap >= 0) encoded = encoded.replaceAt(i, base64Map[iMap]);\n  } // return decoded 'encoded' string\n\n\n  return encoded;\n} // Encryption and communication\n\n\n_c6 = Decode;\nmodule.exports.client = {\n  // AskConnection: function() {},\n\n  /**\r\n   * Initiate the connection with the server. Generate RSA keys pair to send the public one to the server.\r\n   * @param {String} ref Server's reference\r\n   * @param {function} callback (err, res) res: This public key\r\n   */\n  InitiateConnection: async function (ref, callback) {\n    try {\n      let conn = MakeConnection(ref);\n\n      if (conn) {\n        conn.privateKey = new NodeRSA({\n          b: 2048\n        });\n        conn.privateKey = conn.privateKey.generateKeyPair(2048);\n        conn.publicKey = conn.privateKey.exportKey('public');\n        callback(false, {\n          'publicKey': conn.publicKey\n        });\n      } else throw 'Unable to create the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Store the server's public key if the connection was accepted.\r\n   * @param {String} ref Server's reference\r\n   * @param {RSA} connPublicKey Server's public key\r\n   * @param {function} callback (err, res) res: true if the connection was accepted\r\n   */\n  ConnectionAccepted: async function (ref, connPublicKey, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        conn.connPublicKey = connPublicKey;\n        callback(false, {\n          'connection': true\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Encode the message with a random key and encrypt the key to securely send them.\r\n   * @param {String} ref End point's reference\r\n   * @param {String} message The message to send\r\n   * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n   */\n  EncryptForSending: async function (ref, message, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        // Encoding key generation and encryption\n        console.log(\"---ENCRYPT---\");\n        console.log(conn.connPublicKey);\n        let key = GenerateEncodingKey();\n        let tempKey = new NodeRSA();\n        tempKey.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        tempKey.importKey(conn.connPublicKey, 'public');\n        let encryptedKey = tempKey.encrypt(key); // Message conversion to base 64 and encoding\n\n        let mes64 = Buffer.from(message).toString('base64');\n        let encodedMsg = Encode(mes64, key);\n        console.log(tempKey.exportKey('public'));\n        console.log(key);\n        console.log(encryptedKey); // TEST\n\n        tempKey = new NodeRSA();\n        tempKey.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        tempKey.importKey(conn.publicKey, 'public');\n        encryptedKey = tempKey.encrypt(key);\n        let decryptedKey = conn.privateKey.decrypt(encryptedKey);\n        console.log(\"---TEST ENCRYPT---\");\n        console.log(conn.publicKey);\n        console.log(tempKey.exportKey('public'));\n        console.log(key);\n        console.log(encryptedKey);\n        console.log(decryptedKey); // END TEST\n        // Encoded message + Encrypted Key\n\n        callback(false, {\n          'encodedMsg': encodedMsg,\n          'encryptedKey': encryptedKey\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Decode the message with the decrypted key.\r\n   * @param {String} ref End point's reference\r\n   * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n   * @param {function} callback (err, res) res: The decoded message\r\n   */\n  DecryptReceived: async function (ref, encryptedMessage, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        // Encoding key decryption\n        let decryptedKey = JSON.parse(conn.privateKey.decrypt(encryptedMessage.encryptedKey)); // Message decoding\n\n        let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\n        let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii'); // Message conversion from base 64\n\n        callback(false, decodedMsg);\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  }\n};\nmodule.exports.server = {\n  //AuthorizeConnection: function() {},\n\n  /**\r\n   * Establish the connection, generate the RSA keys pair and store the client's public key.\r\n   * @param {String} ref Client's ref\r\n   * @param {RSA} connPublicKey Client's public key\r\n   * @param {function} callback (err, res) res: The connection created\r\n   */\n  EstablishConnection: async function (ref, connPublicKey, callback) {\n    try {\n      let conn = MakeConnection(ref);\n\n      if (conn) {\n        conn.privateKey = new NodeRSA({\n          b: 2048\n        });\n        conn.privateKey = conn.privateKey.generateKeyPair(2048);\n        conn.publicKey = conn.privateKey.exportKey('public');\n        conn.connPublicKey = connPublicKey;\n        callback(false, {\n          'publicKey': conn.publicKey\n        });\n      } else throw 'Unable to create the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Encode the message with a random key and encrypt the key to securely send them.\r\n   * @param {String} ref End point's reference\r\n   * @param {String} message The message to send\r\n   * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n   */\n  EncryptForSending: async function (ref, message, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        // Encoding key generation and encryption\n        let key = GenerateEncodingKey();\n        let tempKey = new NodeRSA();\n        let encryptedKey = tempKey.importKey(conn.connPublicKey, 'public').encrypt(key); // Message conversion to base 64 and encoding\n\n        let mes64 = Buffer.from(message).toString('base64');\n        let encodedMsg = Encode(mes64, key); // Encoded message + Encrypted Key\n\n        callback(false, {\n          'encodedMsg': encodedMsg,\n          'encryptedKey': encryptedKey\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Decode the message with the decrypted key.\r\n   * @param {String} ref End point's reference\r\n   * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n   * @param {function} callback (err, res) res: The decoded message\r\n   */\n  DecryptReceived: async function (ref, encryptedMessage, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        console.log(\"---DECRYPT---\");\n        console.log(conn); // Encoding key decryption\n\n        console.log(encryptedMessage.encryptedKey);\n        let decryptedKey = conn.privateKey.decrypt(encryptedMessage.encryptedKey);\n        console.log(decryptedKey.toString());\n        decryptedKey = JSON.parse(decryptedKey);\n        console.log(decryptedKey); // Message decoding\n\n        let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\n        let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii'); // Message conversion from base 64\n\n        callback(false, decodedMsg);\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      console.error(error);\n      callback(error, null);\n    }\n  }\n};\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"MakeConnection\");\n$RefreshReg$(_c2, \"GetConnection\");\n$RefreshReg$(_c3, \"DeleteConnection\");\n$RefreshReg$(_c4, \"GenerateEncodingKey\");\n$RefreshReg$(_c5, \"Encode\");\n$RefreshReg$(_c6, \"Decode\");","map":{"version":3,"sources":["C:/Users/vince/OneDrive/Documents/A5 - Option 1/cybersecurite/freezebee/src/encryption/encryption.js"],"names":["NodeRSA","require","base64Map","String","prototype","replaceAt","index","replacement","substr","length","connections","MakeConnection","interlocutor","authorised","privateKey","publicKey","connPublicKey","GetConnection","conn","push","find","c","DeleteConnection","splice","indexOf","getRandomInt","start","Math","floor","random","GenerateEncodingKey","subKey","base64MapCopy","transKey","polyAlphaKey","numberMap","i","substring","transKeyLength","polyAlphaKeyLength","Encode","toEncode","key","iMap","transposed","iTrans","iPoly","Decode","encoded","module","exports","client","InitiateConnection","ref","callback","b","generateKeyPair","exportKey","error","ConnectionAccepted","EncryptForSending","message","console","log","tempKey","setOptions","encryptionScheme","importKey","encryptedKey","encrypt","mes64","Buffer","from","toString","encodedMsg","decryptedKey","decrypt","DecryptReceived","encryptedMessage","JSON","parse","decodedMsg64","decodedMsg","server","EstablishConnection"],"mappings":"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","sourcesContent":["const NodeRSA = require('node-rsa');\r\n\r\nconst base64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\r\n\r\nString.prototype.replaceAt = function(index, replacement) {\r\n    return this.substr(0, index) + replacement + this.substr(index + replacement.length);\r\n}\r\n\r\n// Connections\r\nvar connections = [];\r\n/**\r\n * Create the connection with the given options.\r\n * @param {String} interlocutor The reference to the end point (ip, url, ...)\r\n * @param {bool} authorised \r\n * @param {RSA} privateKey \r\n * @param {RSA} publicKey \r\n * @param {RSA} connPublicKey \r\n * @returns new connection, null if the interlocutor already exists\r\n */\r\nfunction MakeConnection(interlocutor, authorised = true, privateKey = null, publicKey = null, connPublicKey = null) {\r\n    if (GetConnection(interlocutor)) return null;\r\n    else {\r\n        let conn = {\r\n            'interlocutor': interlocutor,\r\n            'authorised': authorised,\r\n            'privateKey': privateKey,\r\n            'publicKey': publicKey,\r\n            'connPublicKey': connPublicKey,\r\n        };\r\n        connections.push(conn);\r\n        return conn;\r\n    }\r\n}\r\nfunction GetConnection(interlocutor) {\r\n    return connections.find(c => c.interlocutor == interlocutor);\r\n}\r\nfunction DeleteConnection(interlocutor) {\r\n    let conn = GetConnection(interlocutor);\r\n    if (conn) connections.splice(connections.indexOf(conn));\r\n}\r\n\r\n// Content encoding\r\nfunction getRandomInt(start = 0, length = 1) {\r\n    return Math.floor(Math.random() * (length) + start);\r\n}\r\n/**\r\n * Randomly generate a set of keys.\r\n * @returns Set of keys to encode a message\r\n */\r\nfunction GenerateEncodingKey() {\r\n    let subKey = '', base64MapCopy = base64Map;\r\n    let transKey = [], polyAlphaKey = [], numberMap = [];\r\n    // substitution key generation using base 64 map\r\n    while (base64MapCopy.length > 0) {\r\n        let i = getRandomInt(0, base64MapCopy.length);\r\n        subKey += base64MapCopy[i];\r\n        base64MapCopy = base64MapCopy.substr(0, i) + base64MapCopy.substring(i + 1);\r\n    }\r\n    // number map generation\r\n    let transKeyLength = getRandomInt(20, 10);\r\n    for (let i = 0; i < transKeyLength; i++) {\r\n        numberMap.push(i);\r\n    }\r\n    // transposition key generation using number map\r\n    while (numberMap.length > 0) {\r\n        let i = getRandomInt(0, numberMap.length);\r\n        transKey.push(numberMap[i]);\r\n        numberMap.splice(i, 1);\r\n    }\r\n    // poly alpha key generation\r\n    let polyAlphaKeyLength = getRandomInt(16, 8);\r\n    for (let i = 0; i < polyAlphaKeyLength; i++) {\r\n        polyAlphaKey.push(getRandomInt(0, 26));\r\n    }\r\n    return {\r\n        'subKey': subKey,\r\n        'transKey': transKey,\r\n        'polyAlphaKey': polyAlphaKey,\r\n    };\r\n}\r\n/**\r\n * Encode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} toEncode The message to encode (base 64)\r\n * @param {Object} key Set of keys\r\n * @returns Encoded message\r\n */\r\nfunction Encode(toEncode, key) {\r\n    // substitution\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iMap = base64Map.indexOf(toEncode[i]);\r\n        if (iMap >= 0) toEncode = toEncode.replaceAt(i, key.subKey[iMap])\r\n    }\r\n    // transposition\r\n    while (toEncode.length % key.transKey.length != 0) toEncode += '*'\r\n    let transposed = toEncode\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length)\r\n        transposed = transposed.replaceAt(iTrans, toEncode[i])\r\n    }\r\n    toEncode = transposed;\r\n    // custom polyalpha substition\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iMap = base64Map.indexOf(toEncode[i]);\r\n        if (iMap >= 0) {\r\n            let iPoly = i % key.polyAlphaKey.length\r\n            iMap = (iMap + key.polyAlphaKey[iPoly]) % key.subKey.length\r\n            toEncode = toEncode.replaceAt(i, key.subKey[iMap])\r\n        }\r\n    }\r\n    // return encoded 'toEncode' string\r\n    return toEncode\r\n}\r\n/**\r\n * Decode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} encoded Encoded message to decode\r\n * @param {Object} key Set of keys\r\n * @returns Decoded message (base 64)\r\n */\r\nfunction Decode(encoded, key) {\r\n    // custom polyalpha substition\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iMap = key.subKey.indexOf(encoded[i]);\r\n        if (iMap >= 0) {\r\n            let iPoly = i % key.polyAlphaKey.length\r\n            iMap = (iMap - key.polyAlphaKey[iPoly] + base64Map.length) % base64Map.length\r\n            encoded = encoded.replaceAt(i, base64Map[iMap])\r\n        }\r\n    }\r\n    // transposition\r\n    let transposed = encoded\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length)\r\n        transposed = transposed.replaceAt(i, encoded[iTrans])\r\n    }\r\n    encoded = transposed;\r\n    while (encoded[encoded.length - 1] == '*') encoded = encoded.substr(0, encoded.length - 1)\r\n    // substitution\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iMap = key.subKey.indexOf(encoded[i]);\r\n        if (iMap >= 0) encoded = encoded.replaceAt(i, base64Map[iMap])\r\n    }\r\n    // return decoded 'encoded' string\r\n    return encoded\r\n}\r\n\r\n// Encryption and communication\r\nmodule.exports.client = {\r\n    // AskConnection: function() {},\r\n\r\n    /**\r\n     * Initiate the connection with the server. Generate RSA keys pair to send the public one to the server.\r\n     * @param {String} ref Server's reference\r\n     * @param {function} callback (err, res) res: This public key\r\n     */\r\n    InitiateConnection: async function(ref, callback) {\r\n        try {\r\n            let conn = MakeConnection(ref);\r\n            if (conn) {\r\n                conn.privateKey = new NodeRSA({b: 2048});\r\n                conn.privateKey = conn.privateKey.generateKeyPair(2048);\r\n                conn.publicKey = conn.privateKey.exportKey('public');\r\n                callback(false, {'publicKey': conn.publicKey});\r\n            }\r\n            else throw 'Unable to create the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Store the server's public key if the connection was accepted.\r\n     * @param {String} ref Server's reference\r\n     * @param {RSA} connPublicKey Server's public key\r\n     * @param {function} callback (err, res) res: true if the connection was accepted\r\n     */\r\n    ConnectionAccepted: async function(ref, connPublicKey, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                conn.connPublicKey = connPublicKey;\r\n                callback(false, {'connection': true});\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Encode the message with a random key and encrypt the key to securely send them.\r\n     * @param {String} ref End point's reference\r\n     * @param {String} message The message to send\r\n     * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n     */\r\n    EncryptForSending: async function(ref, message, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                // Encoding key generation and encryption\r\n                console.log(\"---ENCRYPT---\");\r\n                console.log(conn.connPublicKey);\r\n                \r\n                let key = GenerateEncodingKey();\r\n                let tempKey = new NodeRSA();\r\n                tempKey.setOptions({encryptionScheme: 'pkcs1'});\r\n                tempKey.importKey(conn.connPublicKey, 'public');\r\n                let encryptedKey = tempKey.encrypt(key);\r\n                // Message conversion to base 64 and encoding\r\n                let mes64 = Buffer.from(message).toString('base64');\r\n                let encodedMsg = Encode(mes64, key);\r\n                console.log(tempKey.exportKey('public'));\r\n                console.log(key);\r\n                console.log(encryptedKey);\r\n                \r\n                // TEST\r\n                tempKey = new NodeRSA();\r\n                tempKey.setOptions({encryptionScheme: 'pkcs1'});\r\n                tempKey.importKey(conn.publicKey, 'public');\r\n                encryptedKey = tempKey.encrypt(key);\r\n                let decryptedKey = conn.privateKey.decrypt(encryptedKey);\r\n                console.log(\"---TEST ENCRYPT---\");\r\n                console.log(conn.publicKey);\r\n                console.log(tempKey.exportKey('public'));\r\n                console.log(key);\r\n                console.log(encryptedKey);\r\n                console.log(decryptedKey);\r\n                // END TEST\r\n\r\n                // Encoded message + Encrypted Key\r\n                callback(false, {\r\n                    'encodedMsg': encodedMsg,\r\n                    'encryptedKey': encryptedKey,\r\n                });\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Decode the message with the decrypted key.\r\n     * @param {String} ref End point's reference\r\n     * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n     * @param {function} callback (err, res) res: The decoded message\r\n     */\r\n    DecryptReceived: async function(ref, encryptedMessage, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                // Encoding key decryption\r\n                let decryptedKey = JSON.parse(conn.privateKey.decrypt(encryptedMessage.encryptedKey));\r\n                // Message decoding\r\n                let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\r\n                let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii');\r\n                // Message conversion from base 64\r\n                callback(false, decodedMsg);\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n};\r\n\r\nmodule.exports.server = {\r\n    //AuthorizeConnection: function() {},\r\n\r\n    /**\r\n     * Establish the connection, generate the RSA keys pair and store the client's public key.\r\n     * @param {String} ref Client's ref\r\n     * @param {RSA} connPublicKey Client's public key\r\n     * @param {function} callback (err, res) res: The connection created\r\n     */\r\n    EstablishConnection: async function(ref, connPublicKey, callback) {\r\n        try {\r\n            let conn = MakeConnection(ref);\r\n            if (conn) {\r\n                conn.privateKey = new NodeRSA({b: 2048});\r\n                conn.privateKey = conn.privateKey.generateKeyPair(2048);\r\n                conn.publicKey = conn.privateKey.exportKey('public');\r\n                conn.connPublicKey = connPublicKey;\r\n                callback(false, {'publicKey': conn.publicKey});\r\n            }\r\n            else throw 'Unable to create the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Encode the message with a random key and encrypt the key to securely send them.\r\n     * @param {String} ref End point's reference\r\n     * @param {String} message The message to send\r\n     * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n     */\r\n    EncryptForSending: async function(ref, message, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                // Encoding key generation and encryption\r\n                let key = GenerateEncodingKey();\r\n                let tempKey = new NodeRSA();\r\n                let encryptedKey = tempKey.importKey(conn.connPublicKey, 'public').encrypt(key);\r\n                // Message conversion to base 64 and encoding\r\n                let mes64 = Buffer.from(message).toString('base64');\r\n                let encodedMsg = Encode(mes64, key);\r\n                // Encoded message + Encrypted Key\r\n                callback(false, {\r\n                    'encodedMsg': encodedMsg,\r\n                    'encryptedKey': encryptedKey,\r\n                });\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Decode the message with the decrypted key.\r\n     * @param {String} ref End point's reference\r\n     * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n     * @param {function} callback (err, res) res: The decoded message\r\n     */\r\n    DecryptReceived: async function(ref, encryptedMessage, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                console.log(\"---DECRYPT---\");\r\n                console.log(conn);\r\n                // Encoding key decryption\r\n                console.log(encryptedMessage.encryptedKey);\r\n                let decryptedKey = conn.privateKey.decrypt(encryptedMessage.encryptedKey);\r\n                console.log(decryptedKey.toString());\r\n                decryptedKey = JSON.parse(decryptedKey);\r\n                console.log(decryptedKey);\r\n                // Message decoding\r\n                let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\r\n                let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii');\r\n                // Message conversion from base 64\r\n                callback(false, decodedMsg);\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            console.error(error);\r\n            callback(error, null);\r\n        }\r\n    },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}