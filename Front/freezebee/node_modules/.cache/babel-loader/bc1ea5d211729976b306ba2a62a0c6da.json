{"ast":null,"code":"const NodeRSA = require('node-rsa');\n\nconst base64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\nString.prototype.replaceAt = function (index, replacement) {\n  return this.substr(0, index) + replacement + this.substr(index + replacement.length);\n};\n/**\r\n * Create the connection with the given options.\r\n * @param {bool} authorised \r\n * @param {RSA} privateKey \r\n * @param {RSA} publicKey \r\n * @param {RSA} connPublicKey \r\n * @returns new connection, null if the interlocutor already exists\r\n */\n\n\nfunction MakeConnection(authorised = true, privateKey = null, publicKey = null, connPublicKey = null) {\n  if (GetConnection()) DeleteConnection();\n  let conn = {\n    'interlocutor': 'API',\n    'authorised': authorised,\n    'privateKey': privateKey,\n    'publicKey': publicKey,\n    'connPublicKey': connPublicKey\n  };\n  localStorage.setItem('connection', JSON.stringify(conn));\n  return conn;\n}\n\n_c = MakeConnection;\n\nfunction GetConnection() {\n  return JSON.parse(localStorage.getItem('connection'));\n}\n\n_c2 = GetConnection;\n\nfunction SetConnection(conn) {\n  localStorage.setItem('connection', JSON.stringify(conn));\n}\n\n_c3 = SetConnection;\n\nfunction DeleteConnection() {\n  let conn = GetConnection();\n  if (conn) localStorage.removeItem('connection');\n} // Content encoding\n\n\n_c4 = DeleteConnection;\n\nfunction getRandomInt(start = 0, length = 1) {\n  return Math.floor(Math.random() * length + start);\n}\n/**\r\n * Randomly generate a set of keys.\r\n * @returns Set of keys to encode a message\r\n */\n\n\nfunction GenerateEncodingKey() {\n  let subKey = '',\n      base64MapCopy = base64Map;\n  let transKey = [],\n      polyAlphaKey = [],\n      numberMap = []; // substitution key generation using base 64 map\n\n  while (base64MapCopy.length > 0) {\n    let i = getRandomInt(0, base64MapCopy.length);\n    subKey += base64MapCopy[i];\n    base64MapCopy = base64MapCopy.substr(0, i) + base64MapCopy.substring(i + 1);\n  } // number map generation\n\n\n  let transKeyLength = getRandomInt(20, 10);\n\n  for (let i = 0; i < transKeyLength; i++) {\n    numberMap.push(i);\n  } // transposition key generation using number map\n\n\n  while (numberMap.length > 0) {\n    let i = getRandomInt(0, numberMap.length);\n    transKey.push(numberMap[i]);\n    numberMap.splice(i, 1);\n  } // poly alpha key generation\n\n\n  let polyAlphaKeyLength = getRandomInt(16, 8);\n\n  for (let i = 0; i < polyAlphaKeyLength; i++) {\n    polyAlphaKey.push(getRandomInt(0, 26));\n  }\n\n  return {\n    'subKey': subKey,\n    'transKey': transKey,\n    'polyAlphaKey': polyAlphaKey\n  };\n}\n/**\r\n * Encode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} toEncode The message to encode (base 64)\r\n * @param {Object} key Set of keys\r\n * @returns Encoded message\r\n */\n\n\n_c5 = GenerateEncodingKey;\n\nfunction Encode(toEncode, key) {\n  // substitution\n  for (let i = 0; i < toEncode.length; i++) {\n    let iMap = base64Map.indexOf(toEncode[i]);\n    if (iMap >= 0) toEncode = toEncode.replaceAt(i, key.subKey[iMap]);\n  } // transposition\n\n\n  while (toEncode.length % key.transKey.length != 0) toEncode += '*';\n\n  let transposed = toEncode;\n\n  for (let i = 0; i < toEncode.length; i++) {\n    let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length);\n    transposed = transposed.replaceAt(iTrans, toEncode[i]);\n  }\n\n  toEncode = transposed; // custom polyalpha substition\n\n  for (let i = 0; i < toEncode.length; i++) {\n    let iMap = base64Map.indexOf(toEncode[i]);\n\n    if (iMap >= 0) {\n      let iPoly = i % key.polyAlphaKey.length;\n      iMap = (iMap + key.polyAlphaKey[iPoly]) % key.subKey.length;\n      toEncode = toEncode.replaceAt(i, key.subKey[iMap]);\n    }\n  } // return encoded 'toEncode' string\n\n\n  return toEncode;\n}\n/**\r\n * Decode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} encoded Encoded message to decode\r\n * @param {Object} key Set of keys\r\n * @returns Decoded message (base 64)\r\n */\n\n\n_c6 = Encode;\n\nfunction Decode(encoded, key) {\n  // custom polyalpha substition\n  for (let i = 0; i < encoded.length; i++) {\n    let iMap = key.subKey.indexOf(encoded[i]);\n\n    if (iMap >= 0) {\n      let iPoly = i % key.polyAlphaKey.length;\n      iMap = (iMap - key.polyAlphaKey[iPoly] + base64Map.length) % base64Map.length;\n      encoded = encoded.replaceAt(i, base64Map[iMap]);\n    }\n  } // transposition\n\n\n  let transposed = encoded;\n\n  for (let i = 0; i < encoded.length; i++) {\n    let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length);\n    transposed = transposed.replaceAt(i, encoded[iTrans]);\n  }\n\n  encoded = transposed;\n\n  while (encoded[encoded.length - 1] == '*') encoded = encoded.substr(0, encoded.length - 1); // substitution\n\n\n  for (let i = 0; i < encoded.length; i++) {\n    let iMap = key.subKey.indexOf(encoded[i]);\n    if (iMap >= 0) encoded = encoded.replaceAt(i, base64Map[iMap]);\n  } // return decoded 'encoded' string\n\n\n  return encoded;\n} // Encryption and communication\n\n\n_c7 = Decode;\nmodule.exports.client = {\n  // AskConnection: function() {},\n\n  /**\r\n   * Initiate the connection with the server. Generate RSA keys pair to send the public one to the server.\r\n   * @param {function} callback (err, res) res: This public key\r\n   */\n  InitiateConnection: async function (callback) {\n    try {\n      let conn = MakeConnection();\n\n      if (conn) {\n        let privateRSA = new NodeRSA({\n          b: 2048\n        });\n        privateRSA.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        privateRSA.generateKeyPair(2048);\n        conn.privateKey = privateRSA;\n        conn.publicKey = privateRSA.exportKey('pkcs8-public');\n        callback(false, {\n          'publicKey': conn.publicKey\n        });\n      } else throw 'Unable to create the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Store the server's public key if the connection was accepted.\r\n   * @param {RSA} connPublicKey Server's public key\r\n   * @param {function} callback (err, res) res: true if the connection was accepted\r\n   */\n  ConnectionAccepted: async function (connPublicKey, callback) {\n    try {\n      let conn = GetConnection();\n\n      if (conn) {\n        conn.connPublicKey = connPublicKey;\n        callback(false, {\n          'connection': true\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Encode the message with a random key and encrypt the key to securely send them.\r\n   * @param {String} message The message to send\r\n   * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n   */\n  EncryptForSending: async function (message, callback) {\n    try {\n      let conn = GetConnection();\n      console.log(conn);\n\n      if (conn) {\n        // Encoding key generation and encryption\n        let key = GenerateEncodingKey(); // let key64 = Buffer.from(JSON.stringify(key)).toString('base64');\n\n        let tempKey = new NodeRSA();\n        tempKey.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        tempKey.importKey(conn.connPublicKey, 'pkcs8-public'); // let encryptedKey = tempKey.encrypt(key);\n\n        let encryptedKey = {\n          'subKey': tempKey.encrypt(Buffer.from(key.subKey)),\n          'transKey': tempKey.encrypt(Buffer.from(key.transKey)),\n          'polyAlphaKey': tempKey.encrypt(Buffer.from(key.polyAlphaKey))\n        }; // Message conversion to base 64 and encoding\n\n        let mes64 = Buffer.from(message).toString('base64');\n        let encodedMsg = Encode(mes64, key); // console.log('---ENCRYPT---');\n        // console.log(conn.connPublicKey);\n        // console.log(key);\n        // console.log(encryptedKey);\n        // Encoded message + Encrypted Key\n\n        callback(false, {\n          'encodedMsg': encodedMsg,\n          'encryptedKey': encryptedKey\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Decode the message with the decrypted key.\r\n   * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n   * @param {function} callback (err, res) res: The decoded message\r\n   */\n  DecryptReceived: async function (encryptedMessage, callback) {\n    try {\n      let conn = GetConnection();\n\n      if (conn) {\n        // Encoding key decryption\n        // let decryptedKey = conn.privateKey.decrypt(encryptedMessage.encryptedKey);\n        let decryptedKey = {\n          'subKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.subKey)).toString(),\n          'transKey': Array.from(conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.transKey))),\n          'polyAlphaKey': Array.from(conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.polyAlphaKey)))\n        }; // Message decoding\n\n        let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\n        let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii'); // console.log(\"---DECRYPT---\");\n        // console.log(conn.publicKey);\n        // console.log(encryptedMessage.encryptedKey);\n        // console.log(decryptedKey);\n        // Message conversion from base 64\n\n        callback(false, decodedMsg);\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      console.error(error);\n      callback(error, null);\n    }\n  }\n};\n\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7;\n\n$RefreshReg$(_c, \"MakeConnection\");\n$RefreshReg$(_c2, \"GetConnection\");\n$RefreshReg$(_c3, \"SetConnection\");\n$RefreshReg$(_c4, \"DeleteConnection\");\n$RefreshReg$(_c5, \"GenerateEncodingKey\");\n$RefreshReg$(_c6, \"Encode\");\n$RefreshReg$(_c7, \"Decode\");","map":{"version":3,"sources":["C:/Users/vince/OneDrive/Documents/A5 - Option 1/cybersecurite/freezebee/src/encryption/encryption.js"],"names":["NodeRSA","require","base64Map","String","prototype","replaceAt","index","replacement","substr","length","MakeConnection","authorised","privateKey","publicKey","connPublicKey","GetConnection","DeleteConnection","conn","localStorage","setItem","JSON","stringify","parse","getItem","SetConnection","removeItem","getRandomInt","start","Math","floor","random","GenerateEncodingKey","subKey","base64MapCopy","transKey","polyAlphaKey","numberMap","i","substring","transKeyLength","push","splice","polyAlphaKeyLength","Encode","toEncode","key","iMap","indexOf","transposed","iTrans","iPoly","Decode","encoded","module","exports","client","InitiateConnection","callback","privateRSA","b","setOptions","encryptionScheme","generateKeyPair","exportKey","error","ConnectionAccepted","EncryptForSending","message","console","log","tempKey","importKey","encryptedKey","encrypt","Buffer","from","mes64","toString","encodedMsg","DecryptReceived","encryptedMessage","decryptedKey","decrypt","Array","decodedMsg64","decodedMsg"],"mappings":"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","sourcesContent":["const NodeRSA = require('node-rsa');\r\n\r\nconst base64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\r\n\r\nString.prototype.replaceAt = function(index, replacement) {\r\n    return this.substr(0, index) + replacement + this.substr(index + replacement.length);\r\n}\r\n\r\n/**\r\n * Create the connection with the given options.\r\n * @param {bool} authorised \r\n * @param {RSA} privateKey \r\n * @param {RSA} publicKey \r\n * @param {RSA} connPublicKey \r\n * @returns new connection, null if the interlocutor already exists\r\n */\r\nfunction MakeConnection(authorised = true, privateKey = null, publicKey = null, connPublicKey = null) {\r\n    if (GetConnection()) DeleteConnection();\r\n    let conn = {\r\n        'interlocutor': 'API',\r\n        'authorised': authorised,\r\n        'privateKey': privateKey,\r\n        'publicKey': publicKey,\r\n        'connPublicKey': connPublicKey,\r\n    };\r\n    localStorage.setItem('connection', JSON.stringify(conn));\r\n    return conn;\r\n}\r\nfunction GetConnection() {\r\n    return JSON.parse(localStorage.getItem('connection'));\r\n}\r\nfunction SetConnection(conn) {\r\n    localStorage.setItem('connection', JSON.stringify(conn));\r\n}\r\nfunction DeleteConnection() {\r\n    let conn = GetConnection();\r\n    if (conn) localStorage.removeItem('connection')\r\n}\r\n\r\n// Content encoding\r\nfunction getRandomInt(start = 0, length = 1) {\r\n    return Math.floor(Math.random() * (length) + start);\r\n}\r\n/**\r\n * Randomly generate a set of keys.\r\n * @returns Set of keys to encode a message\r\n */\r\nfunction GenerateEncodingKey() {\r\n    let subKey = '', base64MapCopy = base64Map;\r\n    let transKey = [], polyAlphaKey = [], numberMap = [];\r\n    // substitution key generation using base 64 map\r\n    while (base64MapCopy.length > 0) {\r\n        let i = getRandomInt(0, base64MapCopy.length);\r\n        subKey += base64MapCopy[i];\r\n        base64MapCopy = base64MapCopy.substr(0, i) + base64MapCopy.substring(i + 1);\r\n    }\r\n    // number map generation\r\n    let transKeyLength = getRandomInt(20, 10);\r\n    for (let i = 0; i < transKeyLength; i++) {\r\n        numberMap.push(i);\r\n    }\r\n    // transposition key generation using number map\r\n    while (numberMap.length > 0) {\r\n        let i = getRandomInt(0, numberMap.length);\r\n        transKey.push(numberMap[i]);\r\n        numberMap.splice(i, 1);\r\n    }\r\n    // poly alpha key generation\r\n    let polyAlphaKeyLength = getRandomInt(16, 8);\r\n    for (let i = 0; i < polyAlphaKeyLength; i++) {\r\n        polyAlphaKey.push(getRandomInt(0, 26));\r\n    }\r\n    return {\r\n        'subKey': subKey,\r\n        'transKey': transKey,\r\n        'polyAlphaKey': polyAlphaKey,\r\n    };\r\n}\r\n/**\r\n * Encode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} toEncode The message to encode (base 64)\r\n * @param {Object} key Set of keys\r\n * @returns Encoded message\r\n */\r\nfunction Encode(toEncode, key) {\r\n    // substitution\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iMap = base64Map.indexOf(toEncode[i]);\r\n        if (iMap >= 0) toEncode = toEncode.replaceAt(i, key.subKey[iMap])\r\n    }\r\n    // transposition\r\n    while (toEncode.length % key.transKey.length != 0) toEncode += '*'\r\n    let transposed = toEncode\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length)\r\n        transposed = transposed.replaceAt(iTrans, toEncode[i])\r\n    }\r\n    toEncode = transposed;\r\n    // custom polyalpha substition\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iMap = base64Map.indexOf(toEncode[i]);\r\n        if (iMap >= 0) {\r\n            let iPoly = i % key.polyAlphaKey.length\r\n            iMap = (iMap + key.polyAlphaKey[iPoly]) % key.subKey.length\r\n            toEncode = toEncode.replaceAt(i, key.subKey[iMap])\r\n        }\r\n    }\r\n    // return encoded 'toEncode' string\r\n    return toEncode\r\n}\r\n/**\r\n * Decode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} encoded Encoded message to decode\r\n * @param {Object} key Set of keys\r\n * @returns Decoded message (base 64)\r\n */\r\nfunction Decode(encoded, key) {\r\n    // custom polyalpha substition\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iMap = key.subKey.indexOf(encoded[i]);\r\n        if (iMap >= 0) {\r\n            let iPoly = i % key.polyAlphaKey.length\r\n            iMap = (iMap - key.polyAlphaKey[iPoly] + base64Map.length) % base64Map.length\r\n            encoded = encoded.replaceAt(i, base64Map[iMap])\r\n        }\r\n    }\r\n    // transposition\r\n    let transposed = encoded\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length)\r\n        transposed = transposed.replaceAt(i, encoded[iTrans])\r\n    }\r\n    encoded = transposed;\r\n    while (encoded[encoded.length - 1] == '*') encoded = encoded.substr(0, encoded.length - 1)\r\n    // substitution\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iMap = key.subKey.indexOf(encoded[i]);\r\n        if (iMap >= 0) encoded = encoded.replaceAt(i, base64Map[iMap])\r\n    }\r\n    // return decoded 'encoded' string\r\n    return encoded\r\n}\r\n\r\n// Encryption and communication\r\nmodule.exports.client = {\r\n    // AskConnection: function() {},\r\n\r\n    /**\r\n     * Initiate the connection with the server. Generate RSA keys pair to send the public one to the server.\r\n     * @param {function} callback (err, res) res: This public key\r\n     */\r\n    InitiateConnection: async function(callback) {\r\n        try {\r\n            let conn = MakeConnection();\r\n            if (conn) {\r\n                let privateRSA = new NodeRSA({b: 2048});\r\n                privateRSA.setOptions({encryptionScheme: 'pkcs1'});\r\n                privateRSA.generateKeyPair(2048);\r\n                conn.privateKey = privateRSA;\r\n                conn.publicKey = privateRSA.exportKey('pkcs8-public');\r\n                callback(false, {'publicKey': conn.publicKey});\r\n            } else throw 'Unable to create the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Store the server's public key if the connection was accepted.\r\n     * @param {RSA} connPublicKey Server's public key\r\n     * @param {function} callback (err, res) res: true if the connection was accepted\r\n     */\r\n    ConnectionAccepted: async function(connPublicKey, callback) {\r\n        try {\r\n            let conn = GetConnection();\r\n            if (conn) {\r\n                conn.connPublicKey = connPublicKey;\r\n                callback(false, {'connection': true});\r\n            } else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Encode the message with a random key and encrypt the key to securely send them.\r\n     * @param {String} message The message to send\r\n     * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n     */\r\n     EncryptForSending: async function(message, callback) {\r\n        try {\r\n            let conn = GetConnection();\r\n            console.log(conn);\r\n            if (conn) {\r\n                // Encoding key generation and encryption\r\n                let key = GenerateEncodingKey();\r\n                // let key64 = Buffer.from(JSON.stringify(key)).toString('base64');\r\n                let tempKey = new NodeRSA();\r\n                tempKey.setOptions({encryptionScheme: 'pkcs1'});\r\n                tempKey.importKey(conn.connPublicKey, 'pkcs8-public');\r\n                // let encryptedKey = tempKey.encrypt(key);\r\n                let encryptedKey = {\r\n                    'subKey': tempKey.encrypt(Buffer.from(key.subKey)),\r\n                    'transKey': tempKey.encrypt(Buffer.from(key.transKey)),\r\n                    'polyAlphaKey': tempKey.encrypt(Buffer.from(key.polyAlphaKey)),\r\n                };\r\n                // Message conversion to base 64 and encoding\r\n                let mes64 = Buffer.from(message).toString('base64');\r\n                let encodedMsg = Encode(mes64, key);\r\n                \r\n                // console.log('---ENCRYPT---');\r\n                // console.log(conn.connPublicKey);\r\n                // console.log(key);\r\n                // console.log(encryptedKey);\r\n\r\n                // Encoded message + Encrypted Key\r\n                callback(false, {\r\n                    'encodedMsg': encodedMsg,\r\n                    'encryptedKey': encryptedKey,\r\n                });\r\n            } else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Decode the message with the decrypted key.\r\n     * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n     * @param {function} callback (err, res) res: The decoded message\r\n     */\r\n    DecryptReceived: async function(encryptedMessage, callback) {\r\n        try {\r\n            let conn = GetConnection();\r\n            if (conn) {\r\n                // Encoding key decryption\r\n                // let decryptedKey = conn.privateKey.decrypt(encryptedMessage.encryptedKey);\r\n                let decryptedKey = {\r\n                    'subKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.subKey)).toString(),\r\n                    'transKey': Array.from(conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.transKey))),\r\n                    'polyAlphaKey': Array.from(conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.polyAlphaKey))),\r\n                };\r\n                // Message decoding\r\n                let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\r\n                let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii');\r\n\r\n                // console.log(\"---DECRYPT---\");\r\n                // console.log(conn.publicKey);\r\n                // console.log(encryptedMessage.encryptedKey);\r\n                // console.log(decryptedKey);\r\n\r\n                // Message conversion from base 64\r\n                callback(false, decodedMsg);\r\n            } else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            console.error(error);\r\n            callback(error, null);\r\n        }\r\n    },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}