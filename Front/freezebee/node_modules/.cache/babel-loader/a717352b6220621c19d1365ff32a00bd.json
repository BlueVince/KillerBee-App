{"ast":null,"code":"const NodeRSA = require('node-rsa');\n\nconst base64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nconst privateKeyConfig = '-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAjZS7lxRkhsLjlCoOzYZwaaJsEaBPNZcDbPZ8t1K2Z5cOl8qIDDW7kuS+1tuRojJd4zmKf+2icVvRcdyxHpnMTehYyhuNeQSRE/IWZ7Z5dHfuOW+7xGWdDQShKDRd8af7O22cW8lE5oGv0AesZ0rkdCGurbCNEkfDoVvzHJ05RqACqCQg3iHvJ43hBlC3JFj2Vgv+HjhALrzzU54DFnW9MmjVOVEesfygXZr2wFiQGvL9nwZOSQBhmvzz8uhPoJJAPYAokmKtnXdZ2SQY+ZcLjXaP2Szug8hrTldalRCegP6QGYXiaMJd1WAqkbXs8oa03ahu477IyIOM8ujtk76y8QIDAQABAoIBAF7iK6n/h7NszvoQCaWhkJqquIRDjHIcx7XxpvlxHD9mU+hUWkLci93RITh7JCmwWY2blX9QscoIv9/wCF+6sNoRedfRCUnuTpAwcOWGu/TbHzMs94iSlOMRlDOOjNsUOeHE/sHgrCVTCpF/YwJChcJyhE9w/8odgDUWm2I02BrExFq7loVRmY74H4PbLZnVHjHUQ/Bgqy0XsN8Bzr6jGZ6rbNZOdF7siW0pxKYSTO3S8drO0Zwrog5RhfI7N44AxFNK049z+VPvbSJ7p1xqYGKmFCxZvDbe2gfQvOZTi6hSOxnWhl28pBABoMSJr4x9en/efhl/ioe5DAWe+XG5drUCgYEA47jFMgdvuLeMGRKVUqPqKscV8QQuqBtPME2F9OzWTJbodT8hI95f4kbMLTnGIdYh+NltKlQjJZWr9WeU0BW+xgnOclkaN04ARDY/hvJpgBtV98EVnZcd3kAzX4tDQhgPsvBvktnSiMHgeW6ph+obx8Wd+b0hLVzENNvTbtsPQBMCgYEAnymQexaN2TL9HAfKSDiVrwiJx5LojdYbOPlcOQkYEunMI3dBv1TW+Xkc0n22dqNVpUJfu08dEYe8HJSoKRooDhANFp9DhszYvL0BpQXwHKedNi0ZGiqoyRYfDpxKfY7lS/B5xoOAQXY/4ZhmVgRrSCEoKpo9mPQuWKnO+sqwyWsCgYApnPIsGj/IOYJYcpTm7R01g/v2dxUvkw39fa0k/MKMbGc+RbMAovpSly1odk5GkKLUnqbcPVPO4nLx/WOsQs0B03juXGn2AUL7NA6X0mSFDHnBNH+GtL64hnLc2s4Hne4AfP9mjndyljs29Yn1VEqPTwV3RaBycalJH4Kbl1xKEQKBgB0+HL6QuUUjuh9RSxgT1WSQVAgn9LRCl0PThN8xzYuECy6k9Z56rvitCN+fm0uW3OB9HmuisHuNDcHOikrq9FsJFe6HGngE4PlkXI3+Vkxde2P9yzPkjJhNiS09B+6jt3tJVoZjmMfuOvRu9LZvH2rkNKYHKrQUgQNnR5EKdoq7AoGAEt442QFvBgkIit2T44p6j+8ewcIzQxWuZwWiWe24QmqlcMvQ0jDr3YTZoBEWeNCAyTSb3OpN2sCKBxdGcYzZ/zpUK1j6M0rObHjfhd0ITKxYhAGXrfBUYN99gNIZzHmdpHYi8+A0xqeNMazB4e/VfYYPUPnAAteOxUhxmWudf1o=-----END RSA PRIVATE KEY-----';\nconst publicKeyConfig = '-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZS7lxRkhsLjlCoOzYZwaaJsEaBPNZcDbPZ8t1K2Z5cOl8qIDDW7kuS+1tuRojJd4zmKf+2icVvRcdyxHpnMTehYyhuNeQSRE/IWZ7Z5dHfuOW+7xGWdDQShKDRd8af7O22cW8lE5oGv0AesZ0rkdCGurbCNEkfDoVvzHJ05RqACqCQg3iHvJ43hBlC3JFj2Vgv+HjhALrzzU54DFnW9MmjVOVEesfygXZr2wFiQGvL9nwZOSQBhmvzz8uhPoJJAPYAokmKtnXdZ2SQY+ZcLjXaP2Szug8hrTldalRCegP6QGYXiaMJd1WAqkbXs8oa03ahu477IyIOM8ujtk76y8QIDAQAB-----END PUBLIC KEY-----';\n\nString.prototype.replaceAt = function (index, replacement) {\n  return this.substr(0, index) + replacement + this.substr(index + replacement.length);\n}; // Connections\n\n\nvar connections = [];\n/**\r\n * Create the connection with the given options.\r\n * @param {String} interlocutor The reference to the end point (ip, url, ...)\r\n * @param {bool} authorised \r\n * @param {RSA} privateKey \r\n * @param {RSA} publicKey \r\n * @param {RSA} connPublicKey \r\n * @returns new connection, null if the interlocutor already exists\r\n */\n\nfunction MakeConnection(interlocutor, authorised = true, privateKey = null, publicKey = null, connPublicKey = null) {\n  if (GetConnection(interlocutor)) return null;else {\n    let conn = {\n      'interlocutor': interlocutor,\n      'authorised': authorised,\n      'privateKey': privateKey,\n      'publicKey': publicKey,\n      'connPublicKey': connPublicKey\n    };\n    connections.push(conn);\n    return conn;\n  }\n}\n\n_c = MakeConnection;\n\nfunction GetConnection(interlocutor) {\n  return connections.find(c => c.interlocutor == interlocutor);\n}\n\n_c2 = GetConnection;\n\nfunction DeleteConnection(interlocutor) {\n  let conn = GetConnection(interlocutor);\n  if (conn) connections.splice(connections.indexOf(conn));\n} // Content encoding\n\n\n_c3 = DeleteConnection;\n\nfunction getRandomInt(start = 0, length = 1) {\n  return Math.floor(Math.random() * length + start);\n}\n/**\r\n * Randomly generate a set of keys.\r\n * @returns Set of keys to encode a message\r\n */\n\n\nfunction GenerateEncodingKey() {\n  let subKey = '',\n      base64MapCopy = base64Map;\n  let transKey = [],\n      polyAlphaKey = [],\n      numberMap = []; // substitution key generation using base 64 map\n\n  while (base64MapCopy.length > 0) {\n    let i = getRandomInt(0, base64MapCopy.length);\n    subKey += base64MapCopy[i];\n    base64MapCopy = base64MapCopy.substr(0, i) + base64MapCopy.substring(i + 1);\n  } // number map generation\n\n\n  let transKeyLength = getRandomInt(20, 10);\n\n  for (let i = 0; i < transKeyLength; i++) {\n    numberMap.push(i);\n  } // transposition key generation using number map\n\n\n  while (numberMap.length > 0) {\n    let i = getRandomInt(0, numberMap.length);\n    transKey.push(numberMap[i]);\n    numberMap.splice(i, 1);\n  } // poly alpha key generation\n\n\n  let polyAlphaKeyLength = getRandomInt(16, 8);\n\n  for (let i = 0; i < polyAlphaKeyLength; i++) {\n    polyAlphaKey.push(getRandomInt(0, 26));\n  }\n\n  return {\n    'subKey': subKey,\n    'transKey': transKey,\n    'polyAlphaKey': polyAlphaKey\n  };\n}\n/**\r\n * Encode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} toEncode The message to encode (base 64)\r\n * @param {Object} key Set of keys\r\n * @returns Encoded message\r\n */\n\n\n_c4 = GenerateEncodingKey;\n\nfunction Encode(toEncode, key) {\n  // substitution\n  for (let i = 0; i < toEncode.length; i++) {\n    let iMap = base64Map.indexOf(toEncode[i]);\n    if (iMap >= 0) toEncode = toEncode.replaceAt(i, key.subKey[iMap]);\n  } // transposition\n\n\n  while (toEncode.length % key.transKey.length != 0) toEncode += '*';\n\n  let transposed = toEncode;\n\n  for (let i = 0; i < toEncode.length; i++) {\n    let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length);\n    transposed = transposed.replaceAt(iTrans, toEncode[i]);\n  }\n\n  toEncode = transposed; // custom polyalpha substition\n\n  for (let i = 0; i < toEncode.length; i++) {\n    let iMap = base64Map.indexOf(toEncode[i]);\n\n    if (iMap >= 0) {\n      let iPoly = i % key.polyAlphaKey.length;\n      iMap = (iMap + key.polyAlphaKey[iPoly]) % key.subKey.length;\n      toEncode = toEncode.replaceAt(i, key.subKey[iMap]);\n    }\n  } // return encoded 'toEncode' string\n\n\n  return toEncode;\n}\n/**\r\n * Decode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} encoded Encoded message to decode\r\n * @param {Object} key Set of keys\r\n * @returns Decoded message (base 64)\r\n */\n\n\n_c5 = Encode;\n\nfunction Decode(encoded, key) {\n  // custom polyalpha substition\n  for (let i = 0; i < encoded.length; i++) {\n    let iMap = key.subKey.indexOf(encoded[i]);\n\n    if (iMap >= 0) {\n      let iPoly = i % key.polyAlphaKey.length;\n      iMap = (iMap - key.polyAlphaKey[iPoly] + base64Map.length) % base64Map.length;\n      encoded = encoded.replaceAt(i, base64Map[iMap]);\n    }\n  } // transposition\n\n\n  let transposed = encoded;\n\n  for (let i = 0; i < encoded.length; i++) {\n    let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length);\n    transposed = transposed.replaceAt(i, encoded[iTrans]);\n  }\n\n  encoded = transposed;\n\n  while (encoded[encoded.length - 1] == '*') encoded = encoded.substr(0, encoded.length - 1); // substitution\n\n\n  for (let i = 0; i < encoded.length; i++) {\n    let iMap = key.subKey.indexOf(encoded[i]);\n    if (iMap >= 0) encoded = encoded.replaceAt(i, base64Map[iMap]);\n  } // return decoded 'encoded' string\n\n\n  return encoded;\n} // Encryption and communication\n\n\n_c6 = Decode;\nmodule.exports.client = {\n  // AskConnection: function() {},\n\n  /**\r\n   * Initiate the connection with the server. Generate RSA keys pair to send the public one to the server.\r\n   * @param {String} ref Server's reference\r\n   * @param {function} callback (err, res) res: This public key\r\n   */\n  InitiateConnection: async function (ref, callback) {\n    try {\n      let conn = MakeConnection(ref);\n\n      if (conn) {\n        /**/\n        let privateRSA = new NodeRSA({\n          b: 2048\n        });\n        privateRSA.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        privateRSA.generateKeyPair(2048);\n        /*\r\n        let privateRSA = new NodeRSA();\r\n        privateRSA.importKey(privateKeyConfig, 'pkcs1');\r\n        privateRSA.importKey(publicKeyConfig, 'pkcs8-public');\r\n        /**/\n\n        conn.privateKey = privateRSA;\n        conn.publicKey = privateRSA.exportKey('pkcs8-public');\n        callback(false, {\n          'publicKey': conn.publicKey\n        });\n      } else throw 'Unable to create the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Store the server's public key if the connection was accepted.\r\n   * @param {String} ref Server's reference\r\n   * @param {RSA} connPublicKey Server's public key\r\n   * @param {function} callback (err, res) res: true if the connection was accepted\r\n   */\n  ConnectionAccepted: async function (ref, connPublicKey, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        conn.connPublicKey = connPublicKey;\n        callback(false, {\n          'connection': true\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Encode the message with a random key and encrypt the key to securely send them.\r\n   * @param {String} ref End point's reference\r\n   * @param {String} message The message to send\r\n   * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n   */\n  EncryptForSending: async function (ref, message, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        // Encoding key generation and encryption\n        let key = GenerateEncodingKey(); // let key64 = Buffer.from(JSON.stringify(key)).toString('base64');\n\n        let tempKey = new NodeRSA();\n        tempKey.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        tempKey.importKey(conn.connPublicKey, 'pkcs8-public'); // let encryptedKey = tempKey.encrypt(key);\n\n        let encryptedKey = {\n          'subKey': tempKey.encrypt(Buffer.from(key.subKey)),\n          'transKey': tempKey.encrypt(Buffer.from(key.transKey)),\n          'polyAlphaKey': tempKey.encrypt(Buffer.from(key.polyAlphaKey))\n        }; // Message conversion to base 64 and encoding\n\n        let mes64 = Buffer.from(message).toString('base64');\n        let encodedMsg = Encode(mes64, key);\n        console.log('---ENCRYPT---');\n        console.log(conn.connPublicKey);\n        console.log(key);\n        console.log(encryptedKey); // Encoded message + Encrypted Key\n\n        callback(false, {\n          'encodedMsg': encodedMsg,\n          'encryptedKey': encryptedKey\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Decode the message with the decrypted key.\r\n   * @param {String} ref End point's reference\r\n   * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n   * @param {function} callback (err, res) res: The decoded message\r\n   */\n  DecryptReceived: async function (ref, encryptedMessage, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        // Encoding key decryption\n        let decryptedKey = JSON.parse(conn.privateKey.decrypt(encryptedMessage.encryptedKey)); // Message decoding\n\n        let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\n        let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii'); // Message conversion from base 64\n\n        callback(false, decodedMsg);\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  }\n};\nmodule.exports.server = {\n  //AuthorizeConnection: function() {},\n\n  /**\r\n   * Establish the connection, generate the RSA keys pair and store the client's public key.\r\n   * @param {String} ref Client's ref\r\n   * @param {RSA} connPublicKey Client's public key\r\n   * @param {function} callback (err, res) res: The connection created\r\n   */\n  EstablishConnection: async function (ref, connPublicKey, callback) {\n    try {\n      let conn = MakeConnection(ref);\n\n      if (conn) {\n        /**/\n        let privateRSA = new NodeRSA({\n          b: 2048\n        });\n        privateRSA.setOptions({\n          encryptionScheme: 'pkcs1'\n        });\n        privateRSA.generateKeyPair(2048);\n        /*\r\n        let privateRSA = new NodeRSA();\r\n        privateRSA.importKey(privateKeyConfig, 'pkcs1');\r\n        privateRSA.importKey(publicKeyConfig, 'pkcs8-public');\r\n        /**/\n\n        conn.privateKey = privateRSA;\n        conn.publicKey = privateRSA.exportKey('pkcs8-public');\n        conn.connPublicKey = connPublicKey;\n        callback(false, {\n          'publicKey': conn.publicKey\n        });\n      } else throw 'Unable to create the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Encode the message with a random key and encrypt the key to securely send them.\r\n   * @param {String} ref End point's reference\r\n   * @param {String} message The message to send\r\n   * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n   */\n  EncryptForSending: async function (ref, message, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        // Encoding key generation and encryption\n        let key = GenerateEncodingKey();\n        let tempKey = new NodeRSA();\n        let encryptedKey = tempKey.importKey(conn.connPublicKey, 'pkcs8-public').encrypt(key); // Message conversion to base 64 and encoding\n\n        let mes64 = Buffer.from(message).toString('base64');\n        let encodedMsg = Encode(mes64, key); // Encoded message + Encrypted Key\n\n        callback(false, {\n          'encodedMsg': encodedMsg,\n          'encryptedKey': encryptedKey\n        });\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      callback(error, null);\n    }\n  },\n\n  /**\r\n   * Decode the message with the decrypted key.\r\n   * @param {String} ref End point's reference\r\n   * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n   * @param {function} callback (err, res) res: The decoded message\r\n   */\n  DecryptReceived: async function (ref, encryptedMessage, callback) {\n    try {\n      let conn = GetConnection(ref);\n\n      if (conn) {\n        console.log(\"---DECRYPT---\"); // Encoding key decryption\n\n        console.log(conn.publicKey);\n        console.log(encryptedMessage.encryptedKey); // let decryptedKey = conn.privateKey.decrypt(encryptedMessage.encryptedKey);\n\n        let decryptedKey = {\n          'subKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.subKey)),\n          'transKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.transKey)),\n          'polyAlphaKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.polyAlphaKey))\n        };\n        console.log(decryptedKey);\n        decryptedKey = JSON.parse(decryptedKey.toString());\n        console.log(decryptedKey); // Message decoding\n\n        let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\n        let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii'); // Message conversion from base 64\n\n        callback(false, decodedMsg);\n      } else throw 'Unable to find the connection';\n    } catch (error) {\n      console.error(error);\n      callback(error, null);\n    }\n  }\n};\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"MakeConnection\");\n$RefreshReg$(_c2, \"GetConnection\");\n$RefreshReg$(_c3, \"DeleteConnection\");\n$RefreshReg$(_c4, \"GenerateEncodingKey\");\n$RefreshReg$(_c5, \"Encode\");\n$RefreshReg$(_c6, \"Decode\");","map":{"version":3,"sources":["C:/Users/vince/OneDrive/Documents/A5 - Option 1/cybersecurite/freezebee/src/encryption/encryption.js"],"names":["NodeRSA","require","base64Map","privateKeyConfig","publicKeyConfig","String","prototype","replaceAt","index","replacement","substr","length","connections","MakeConnection","interlocutor","authorised","privateKey","publicKey","connPublicKey","GetConnection","conn","push","find","c","DeleteConnection","splice","indexOf","getRandomInt","start","Math","floor","random","GenerateEncodingKey","subKey","base64MapCopy","transKey","polyAlphaKey","numberMap","i","substring","transKeyLength","polyAlphaKeyLength","Encode","toEncode","key","iMap","transposed","iTrans","iPoly","Decode","encoded","module","exports","client","InitiateConnection","ref","callback","privateRSA","b","setOptions","encryptionScheme","generateKeyPair","exportKey","error","ConnectionAccepted","EncryptForSending","message","tempKey","importKey","encryptedKey","encrypt","Buffer","from","mes64","toString","encodedMsg","console","log","DecryptReceived","encryptedMessage","decryptedKey","JSON","parse","decrypt","decodedMsg64","decodedMsg","server","EstablishConnection"],"mappings":"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","sourcesContent":["const NodeRSA = require('node-rsa');\r\n\r\nconst base64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\r\nconst privateKeyConfig = '-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAjZS7lxRkhsLjlCoOzYZwaaJsEaBPNZcDbPZ8t1K2Z5cOl8qIDDW7kuS+1tuRojJd4zmKf+2icVvRcdyxHpnMTehYyhuNeQSRE/IWZ7Z5dHfuOW+7xGWdDQShKDRd8af7O22cW8lE5oGv0AesZ0rkdCGurbCNEkfDoVvzHJ05RqACqCQg3iHvJ43hBlC3JFj2Vgv+HjhALrzzU54DFnW9MmjVOVEesfygXZr2wFiQGvL9nwZOSQBhmvzz8uhPoJJAPYAokmKtnXdZ2SQY+ZcLjXaP2Szug8hrTldalRCegP6QGYXiaMJd1WAqkbXs8oa03ahu477IyIOM8ujtk76y8QIDAQABAoIBAF7iK6n/h7NszvoQCaWhkJqquIRDjHIcx7XxpvlxHD9mU+hUWkLci93RITh7JCmwWY2blX9QscoIv9/wCF+6sNoRedfRCUnuTpAwcOWGu/TbHzMs94iSlOMRlDOOjNsUOeHE/sHgrCVTCpF/YwJChcJyhE9w/8odgDUWm2I02BrExFq7loVRmY74H4PbLZnVHjHUQ/Bgqy0XsN8Bzr6jGZ6rbNZOdF7siW0pxKYSTO3S8drO0Zwrog5RhfI7N44AxFNK049z+VPvbSJ7p1xqYGKmFCxZvDbe2gfQvOZTi6hSOxnWhl28pBABoMSJr4x9en/efhl/ioe5DAWe+XG5drUCgYEA47jFMgdvuLeMGRKVUqPqKscV8QQuqBtPME2F9OzWTJbodT8hI95f4kbMLTnGIdYh+NltKlQjJZWr9WeU0BW+xgnOclkaN04ARDY/hvJpgBtV98EVnZcd3kAzX4tDQhgPsvBvktnSiMHgeW6ph+obx8Wd+b0hLVzENNvTbtsPQBMCgYEAnymQexaN2TL9HAfKSDiVrwiJx5LojdYbOPlcOQkYEunMI3dBv1TW+Xkc0n22dqNVpUJfu08dEYe8HJSoKRooDhANFp9DhszYvL0BpQXwHKedNi0ZGiqoyRYfDpxKfY7lS/B5xoOAQXY/4ZhmVgRrSCEoKpo9mPQuWKnO+sqwyWsCgYApnPIsGj/IOYJYcpTm7R01g/v2dxUvkw39fa0k/MKMbGc+RbMAovpSly1odk5GkKLUnqbcPVPO4nLx/WOsQs0B03juXGn2AUL7NA6X0mSFDHnBNH+GtL64hnLc2s4Hne4AfP9mjndyljs29Yn1VEqPTwV3RaBycalJH4Kbl1xKEQKBgB0+HL6QuUUjuh9RSxgT1WSQVAgn9LRCl0PThN8xzYuECy6k9Z56rvitCN+fm0uW3OB9HmuisHuNDcHOikrq9FsJFe6HGngE4PlkXI3+Vkxde2P9yzPkjJhNiS09B+6jt3tJVoZjmMfuOvRu9LZvH2rkNKYHKrQUgQNnR5EKdoq7AoGAEt442QFvBgkIit2T44p6j+8ewcIzQxWuZwWiWe24QmqlcMvQ0jDr3YTZoBEWeNCAyTSb3OpN2sCKBxdGcYzZ/zpUK1j6M0rObHjfhd0ITKxYhAGXrfBUYN99gNIZzHmdpHYi8+A0xqeNMazB4e/VfYYPUPnAAteOxUhxmWudf1o=-----END RSA PRIVATE KEY-----'\r\nconst publicKeyConfig = '-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZS7lxRkhsLjlCoOzYZwaaJsEaBPNZcDbPZ8t1K2Z5cOl8qIDDW7kuS+1tuRojJd4zmKf+2icVvRcdyxHpnMTehYyhuNeQSRE/IWZ7Z5dHfuOW+7xGWdDQShKDRd8af7O22cW8lE5oGv0AesZ0rkdCGurbCNEkfDoVvzHJ05RqACqCQg3iHvJ43hBlC3JFj2Vgv+HjhALrzzU54DFnW9MmjVOVEesfygXZr2wFiQGvL9nwZOSQBhmvzz8uhPoJJAPYAokmKtnXdZ2SQY+ZcLjXaP2Szug8hrTldalRCegP6QGYXiaMJd1WAqkbXs8oa03ahu477IyIOM8ujtk76y8QIDAQAB-----END PUBLIC KEY-----'\r\n\r\nString.prototype.replaceAt = function(index, replacement) {\r\n    return this.substr(0, index) + replacement + this.substr(index + replacement.length);\r\n}\r\n\r\n// Connections\r\nvar connections = [];\r\n/**\r\n * Create the connection with the given options.\r\n * @param {String} interlocutor The reference to the end point (ip, url, ...)\r\n * @param {bool} authorised \r\n * @param {RSA} privateKey \r\n * @param {RSA} publicKey \r\n * @param {RSA} connPublicKey \r\n * @returns new connection, null if the interlocutor already exists\r\n */\r\nfunction MakeConnection(interlocutor, authorised = true, privateKey = null, publicKey = null, connPublicKey = null) {\r\n    if (GetConnection(interlocutor)) return null;\r\n    else {\r\n        let conn = {\r\n            'interlocutor': interlocutor,\r\n            'authorised': authorised,\r\n            'privateKey': privateKey,\r\n            'publicKey': publicKey,\r\n            'connPublicKey': connPublicKey,\r\n        };\r\n        connections.push(conn);\r\n        return conn;\r\n    }\r\n}\r\nfunction GetConnection(interlocutor) {\r\n    return connections.find(c => c.interlocutor == interlocutor);\r\n}\r\nfunction DeleteConnection(interlocutor) {\r\n    let conn = GetConnection(interlocutor);\r\n    if (conn) connections.splice(connections.indexOf(conn));\r\n}\r\n\r\n// Content encoding\r\nfunction getRandomInt(start = 0, length = 1) {\r\n    return Math.floor(Math.random() * (length) + start);\r\n}\r\n/**\r\n * Randomly generate a set of keys.\r\n * @returns Set of keys to encode a message\r\n */\r\nfunction GenerateEncodingKey() {\r\n    let subKey = '', base64MapCopy = base64Map;\r\n    let transKey = [], polyAlphaKey = [], numberMap = [];\r\n    // substitution key generation using base 64 map\r\n    while (base64MapCopy.length > 0) {\r\n        let i = getRandomInt(0, base64MapCopy.length);\r\n        subKey += base64MapCopy[i];\r\n        base64MapCopy = base64MapCopy.substr(0, i) + base64MapCopy.substring(i + 1);\r\n    }\r\n    // number map generation\r\n    let transKeyLength = getRandomInt(20, 10);\r\n    for (let i = 0; i < transKeyLength; i++) {\r\n        numberMap.push(i);\r\n    }\r\n    // transposition key generation using number map\r\n    while (numberMap.length > 0) {\r\n        let i = getRandomInt(0, numberMap.length);\r\n        transKey.push(numberMap[i]);\r\n        numberMap.splice(i, 1);\r\n    }\r\n    // poly alpha key generation\r\n    let polyAlphaKeyLength = getRandomInt(16, 8);\r\n    for (let i = 0; i < polyAlphaKeyLength; i++) {\r\n        polyAlphaKey.push(getRandomInt(0, 26));\r\n    }\r\n    return {\r\n        'subKey': subKey,\r\n        'transKey': transKey,\r\n        'polyAlphaKey': polyAlphaKey,\r\n    };\r\n}\r\n/**\r\n * Encode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} toEncode The message to encode (base 64)\r\n * @param {Object} key Set of keys\r\n * @returns Encoded message\r\n */\r\nfunction Encode(toEncode, key) {\r\n    // substitution\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iMap = base64Map.indexOf(toEncode[i]);\r\n        if (iMap >= 0) toEncode = toEncode.replaceAt(i, key.subKey[iMap])\r\n    }\r\n    // transposition\r\n    while (toEncode.length % key.transKey.length != 0) toEncode += '*'\r\n    let transposed = toEncode\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length)\r\n        transposed = transposed.replaceAt(iTrans, toEncode[i])\r\n    }\r\n    toEncode = transposed;\r\n    // custom polyalpha substition\r\n    for (let i = 0; i < toEncode.length; i++) {\r\n        let iMap = base64Map.indexOf(toEncode[i]);\r\n        if (iMap >= 0) {\r\n            let iPoly = i % key.polyAlphaKey.length\r\n            iMap = (iMap + key.polyAlphaKey[iPoly]) % key.subKey.length\r\n            toEncode = toEncode.replaceAt(i, key.subKey[iMap])\r\n        }\r\n    }\r\n    // return encoded 'toEncode' string\r\n    return toEncode\r\n}\r\n/**\r\n * Decode a message with the given set of keys, using the custom sysmetric algorithm.\r\n * @param {String} encoded Encoded message to decode\r\n * @param {Object} key Set of keys\r\n * @returns Decoded message (base 64)\r\n */\r\nfunction Decode(encoded, key) {\r\n    // custom polyalpha substition\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iMap = key.subKey.indexOf(encoded[i]);\r\n        if (iMap >= 0) {\r\n            let iPoly = i % key.polyAlphaKey.length\r\n            iMap = (iMap - key.polyAlphaKey[iPoly] + base64Map.length) % base64Map.length\r\n            encoded = encoded.replaceAt(i, base64Map[iMap])\r\n        }\r\n    }\r\n    // transposition\r\n    let transposed = encoded\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iTrans = key.transKey[i % key.transKey.length] + key.transKey.length * Math.floor(i / key.transKey.length)\r\n        transposed = transposed.replaceAt(i, encoded[iTrans])\r\n    }\r\n    encoded = transposed;\r\n    while (encoded[encoded.length - 1] == '*') encoded = encoded.substr(0, encoded.length - 1)\r\n    // substitution\r\n    for (let i = 0; i < encoded.length; i++) {\r\n        let iMap = key.subKey.indexOf(encoded[i]);\r\n        if (iMap >= 0) encoded = encoded.replaceAt(i, base64Map[iMap])\r\n    }\r\n    // return decoded 'encoded' string\r\n    return encoded\r\n}\r\n\r\n// Encryption and communication\r\nmodule.exports.client = {\r\n    // AskConnection: function() {},\r\n\r\n    /**\r\n     * Initiate the connection with the server. Generate RSA keys pair to send the public one to the server.\r\n     * @param {String} ref Server's reference\r\n     * @param {function} callback (err, res) res: This public key\r\n     */\r\n    InitiateConnection: async function(ref, callback) {\r\n        try {\r\n            let conn = MakeConnection(ref);\r\n            if (conn) {\r\n                /**/\r\n                let privateRSA = new NodeRSA({b: 2048});\r\n                privateRSA.setOptions({encryptionScheme: 'pkcs1'});\r\n                privateRSA.generateKeyPair(2048);\r\n                /*\r\n                let privateRSA = new NodeRSA();\r\n                privateRSA.importKey(privateKeyConfig, 'pkcs1');\r\n                privateRSA.importKey(publicKeyConfig, 'pkcs8-public');\r\n                /**/\r\n                conn.privateKey = privateRSA;\r\n                conn.publicKey = privateRSA.exportKey('pkcs8-public');\r\n                callback(false, {'publicKey': conn.publicKey});\r\n            }\r\n            else throw 'Unable to create the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Store the server's public key if the connection was accepted.\r\n     * @param {String} ref Server's reference\r\n     * @param {RSA} connPublicKey Server's public key\r\n     * @param {function} callback (err, res) res: true if the connection was accepted\r\n     */\r\n    ConnectionAccepted: async function(ref, connPublicKey, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                conn.connPublicKey = connPublicKey;\r\n                callback(false, {'connection': true});\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Encode the message with a random key and encrypt the key to securely send them.\r\n     * @param {String} ref End point's reference\r\n     * @param {String} message The message to send\r\n     * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n     */\r\n    EncryptForSending: async function(ref, message, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                // Encoding key generation and encryption\r\n                let key = GenerateEncodingKey();\r\n                // let key64 = Buffer.from(JSON.stringify(key)).toString('base64');\r\n                let tempKey = new NodeRSA();\r\n                tempKey.setOptions({encryptionScheme: 'pkcs1'});\r\n                tempKey.importKey(conn.connPublicKey, 'pkcs8-public');\r\n                // let encryptedKey = tempKey.encrypt(key);\r\n                let encryptedKey = {\r\n                    'subKey': tempKey.encrypt(Buffer.from(key.subKey)),\r\n                    'transKey': tempKey.encrypt(Buffer.from(key.transKey)),\r\n                    'polyAlphaKey': tempKey.encrypt(Buffer.from(key.polyAlphaKey)),\r\n                };\r\n                // Message conversion to base 64 and encoding\r\n                let mes64 = Buffer.from(message).toString('base64');\r\n                let encodedMsg = Encode(mes64, key);\r\n                console.log('---ENCRYPT---');\r\n                console.log(conn.connPublicKey);\r\n                console.log(key);\r\n                console.log(encryptedKey);\r\n\r\n                // Encoded message + Encrypted Key\r\n                callback(false, {\r\n                    'encodedMsg': encodedMsg,\r\n                    'encryptedKey': encryptedKey,\r\n                });\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Decode the message with the decrypted key.\r\n     * @param {String} ref End point's reference\r\n     * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n     * @param {function} callback (err, res) res: The decoded message\r\n     */\r\n    DecryptReceived: async function(ref, encryptedMessage, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                // Encoding key decryption\r\n                let decryptedKey = JSON.parse(conn.privateKey.decrypt(encryptedMessage.encryptedKey));\r\n                // Message decoding\r\n                let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\r\n                let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii');\r\n                // Message conversion from base 64\r\n                callback(false, decodedMsg);\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n};\r\n\r\nmodule.exports.server = {\r\n    //AuthorizeConnection: function() {},\r\n\r\n    /**\r\n     * Establish the connection, generate the RSA keys pair and store the client's public key.\r\n     * @param {String} ref Client's ref\r\n     * @param {RSA} connPublicKey Client's public key\r\n     * @param {function} callback (err, res) res: The connection created\r\n     */\r\n    EstablishConnection: async function(ref, connPublicKey, callback) {\r\n        try {\r\n            let conn = MakeConnection(ref);\r\n            if (conn) {\r\n                /**/\r\n                let privateRSA = new NodeRSA({b: 2048});\r\n                privateRSA.setOptions({encryptionScheme: 'pkcs1'});\r\n                privateRSA.generateKeyPair(2048);\r\n                /*\r\n                let privateRSA = new NodeRSA();\r\n                privateRSA.importKey(privateKeyConfig, 'pkcs1');\r\n                privateRSA.importKey(publicKeyConfig, 'pkcs8-public');\r\n                /**/\r\n                conn.privateKey = privateRSA;\r\n                conn.publicKey = privateRSA.exportKey('pkcs8-public');\r\n                conn.connPublicKey = connPublicKey;\r\n                callback(false, {'publicKey': conn.publicKey});\r\n            }\r\n            else throw 'Unable to create the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Encode the message with a random key and encrypt the key to securely send them.\r\n     * @param {String} ref End point's reference\r\n     * @param {String} message The message to send\r\n     * @param {function} callback (err, res) res: {String: encodedMsg, Object: encryptedKey} Set composed of the encoded message and the encrypted key\r\n     */\r\n    EncryptForSending: async function(ref, message, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                // Encoding key generation and encryption\r\n                let key = GenerateEncodingKey();\r\n                let tempKey = new NodeRSA();\r\n                let encryptedKey = tempKey.importKey(conn.connPublicKey, 'pkcs8-public').encrypt(key);\r\n                // Message conversion to base 64 and encoding\r\n                let mes64 = Buffer.from(message).toString('base64');\r\n                let encodedMsg = Encode(mes64, key);\r\n                // Encoded message + Encrypted Key\r\n                callback(false, {\r\n                    'encodedMsg': encodedMsg,\r\n                    'encryptedKey': encryptedKey,\r\n                });\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            callback(error, null);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Decode the message with the decrypted key.\r\n     * @param {String} ref End point's reference\r\n     * @param {Object} encryptedMessage Set composed of the encoded message and the encrypted key\r\n     * @param {function} callback (err, res) res: The decoded message\r\n     */\r\n    DecryptReceived: async function(ref, encryptedMessage, callback) {\r\n        try {\r\n            let conn = GetConnection(ref);\r\n            if (conn) {\r\n                console.log(\"---DECRYPT---\");\r\n                // Encoding key decryption\r\n                console.log(conn.publicKey);\r\n                console.log(encryptedMessage.encryptedKey);\r\n                // let decryptedKey = conn.privateKey.decrypt(encryptedMessage.encryptedKey);\r\n                let decryptedKey = {\r\n                    'subKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.subKey)),\r\n                    'transKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.transKey)),\r\n                    'polyAlphaKey': conn.privateKey.decrypt(Buffer.from(encryptedMessage.encryptedKey.polyAlphaKey)),\r\n                };\r\n                console.log(decryptedKey);\r\n                decryptedKey = JSON.parse(decryptedKey.toString());\r\n                console.log(decryptedKey);\r\n                // Message decoding\r\n                let decodedMsg64 = Decode(encryptedMessage.encodedMsg, decryptedKey);\r\n                let decodedMsg = Buffer.from(decodedMsg64, 'base64').toString('ascii');\r\n                // Message conversion from base 64\r\n                callback(false, decodedMsg);\r\n            }\r\n            else throw 'Unable to find the connection';\r\n        } catch (error) {\r\n            console.error(error);\r\n            callback(error, null);\r\n        }\r\n    },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}